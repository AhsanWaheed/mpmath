Numerical inverse Laplace transform
-----------------------------------

One-step algorithm (``invertlaplace``)
......................................

.. autofunction:: mpmath.invertlaplace

Specific algorithms
...................

Fixed Talbot algorithm
~~~~~~~~~~~~~~~~~~~~~~

.. autoclass:: mpmath.calculus.inverselaplace.FixedTalbot
   :members:

Gaver-Stehfest algorithm
~~~~~~~~~~~~~~~~~~~~~~~~

.. autoclass:: mpmath.calculus.inverselaplace.Stehfest
   :members:

de Hoog, Knight & Stokes algorithm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. autoclass:: mpmath.calculus.inverselaplace.deHoog
   :members:

Manual approach 
...............

It is possible and sometimes beneficial to re-create some of the
functionality in ``invertlaplace``. This could be used to compute the
Laplace-space function evaluations in a different way.  For example,
the Laplace-space function evaluations could be the result of a
quadrature or sum, solution to a system of ordinary differential
equations, or possibly computed in parallel from some external library
or function call.

A trivial example showing the process (which could be implemented
using the existing interface):

>>> from mpmath import *
>>> mp.dps = 20
>>> myTalbot = calculus.inverselaplace.FixedTalbot(mp)
>>> myTalbot.dps_orig,myTalbot.dps_goal

>>> t = 0.25
>>> myTalbot.calc_laplace_parameter(t)
>>> fp = lambda p: 1/(p + 1) - 1/(p + 1000)
>>> ft = lambda t: exp(-t) - exp(-1000*t)
>>> fpvec = map(fp,myTalbot.p)
>>> ft(t)-myTalbot.calc_time_domain_solution(fpvec,t,manual_prec=True)
 mpf('-6.1906035853098729e-12')
>>>  

